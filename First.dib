#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# First

Self made practices with basic algorithms

# Primes for learning basics

## Getting started

#!fsharp

let isPrime number = 
    if number = 2 
        then true
        else if number < 2 
            then false
            else 2 :: [3 .. 2 .. number-1] |> List.filter (fun divider -> number % divider = 0) |> List.isEmpty

let printNumAndRes number = 
    printfn "%d is %s!" number (if isPrime number then "prime" else "not prime")

[1 .. 20] |> List.iter printNumAndRes

#!markdown

## Wrong

From years of imperative programming if is the first keyword came into my mind but it is much better with match

#!fsharp

let isPrime number = 
    match number with 
    | x when x < 2 -> false
    | 2 -> true
    | _ -> 2 :: [3 .. 2 .. number-1] |> List.filter (fun divider -> number % divider = 0) |> List.isEmpty

// Looks great

[1 .. 20] |> List.iter printNumAndRes

#!markdown

## Recursion

#!fsharp

let rec nextPrime actualNumber =

    let nextNumber = actualNumber + 1

    match isPrime nextNumber with
    | true -> nextNumber
    | false -> nextPrime nextNumber

nextPrime 7

#!markdown

## Find prime with mutable internal variable

#!fsharp

let findPrime nth =

    let mutable prime = 2

    for _ in [2..nth] do
        prime <- nextPrime prime

    prime
   

findPrime 10

#!markdown

## WO mutable internal variable

#!fsharp

let rec findPrimeRec nth  = 
    if nth > 0
        then nextPrime (findPrimeRec nth-1)
        else nextPrime 2

findPrime 10

#!markdown

## Calculus

### Inplace integration

#!fsharp

#r "nuget: Plotly.NET.Interactive, 5.0.0"

open System
open Plotly.NET

// funtion definitions

let listBuilder from until step =
    [0 .. (int)((until-from)/step)] |> List.map (fun e -> double e * step + from)


let integrate (y_list: list<double>) (x_list: list<double>) =

    (0.0, (y_list |>  List.windowed 2, x_list |> List.windowed 2) 
        ||> List.map2 (fun y x -> (y.[1] + y.[0]) / 2.0 * (x.[1] - x.[0])))
            ||> List.scan (fun acc y -> acc+y)

let differentiate (y_list: list<double>) (x_list: list<double>) =
    
    (y_list |>  List.windowed 2, x_list |> List.windowed 2) 
        ||> List.map2 (fun y x -> (y.[1] - y.[0]) / (x.[1] - x.[0]))

// evaluation

let t = listBuilder 0.0 (2.0 * 2.0 * float Math.PI) 0.01

let cos = t |> List.map (fun x -> double (Math.Cos x))
    
let cos_integrated = integrate cos t
let cos_differentiated = differentiate cos t

[
    Chart.Line(t, cos, Name = "Cos(x)")
    Chart.Line(t, cos_integrated, Name = "Integral of Cos(x) dx")
    //Chart.Line(t, cos_differentiated)

] |> Chart.combine  |> Chart.withLegendStyle(
                            Orientation = StyleParam.Orientation.Horizontal,
                            X = 0.5,
                            XAnchor = StyleParam.XAnchorPosition.Center)

#!fsharp

a.Length
